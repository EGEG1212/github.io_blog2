---
layout: post
current: post
cover: assets/built/images/algorithm-logo.png
navigation: True
title: 컴퓨터 알고리즘 중급
date: 2021-04-18 16:40:00
tags: [algorithm]
class: post-template
subclass: "post tag-algorithm"
author: egeg1212
---

{% include table-of-contents-algorithm.html %}

# 컴퓨터 알고리즘 중급

> ... ㄱㄱㄱ

<br><br>

| **강좌정보** | [Tacademy강좌링크](https://tacademy.skplanet.com/live/player/onlineLectureDetail.action?seq=104)                                                                                        |
| :----------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **학습내용** | Graph, Greedy, Dynamic programming 등 컴퓨터 알고리즘 이론을 보다 깊이 있게 학습하고 이해한다.<br>Maximum Flow, Number Theory, String matching 등의 심화 알고리즘 관련 지식을 학습한다. |
|   **강사**   | 조호성 박사 (한양대학교 SW융합원)                                                                                                                                                       |
| **학습기간** | 2021.04.27~ + 테스트20문항 **이수중**                                                                                                                                                   |
| **학습시간** | **이수중**                                                                                                                                                                              |
| **강의목록** | [1강] 컴퓨터 알고리즘 성능분석(1)                                                                                                                                                       |
|              | [2강] 컴퓨터 알고리즘 성능분석(2)                                                                                                                                                       |
|              | [3강] 확률분석(1)                                                                                                                                                                       |
|              | [4강] 확률분석(2)                                                                                                                                                                       |
|              | [5강] 동적계획법(1)                                                                                                                                                                     |
|              | [6강] 동적계획법(2)                                                                                                                                                                     |
|              | [7강] Greedy Approach(1)                                                                                                                                                                |
|              | [8강] Greedy Approach(2)                                                                                                                                                                |
|              | [9강] 스트링 매칭(1)                                                                                                                                                                    |
|              | [10강] 스트링 매칭 (2)                                                                                                                                                                  |
|              | [11강] 정수론(1)                                                                                                                                                                        |
|              | [12강] 정수론 (2)                                                                                                                                                                       |
|              | [13강] Flow networks (1)                                                                                                                                                                |
|              | [14강] Flow networks (2)                                                                                                                                                                |
|              | [15강] Amortized Analysis                                                                                                                                                               |
|  **GitHub**  | None                                                                                                                                                                                    |

<br>

### 컴퓨터 알고리즘 정의 4가지

**문제를 해결하기 위한 과정을 상세하게 단계적으로 표현한 것**으로 입력과 출력으로 문제를 정의
|단계|내용|
|:-:|:-:|
|문제정의|현실 세계의 문제를 컴퓨터를 이용하여 풀 수 있도록 입력과 출력의 형태로 정의|
|알고리즘 설명|문제를 해결하기 위한 단계를 차례대로 설명|
|정확성 증명|항상 올바른 답을 내고 정상적으로 종료되는지 증명|
|성능분석|수행시간이나 사용공간에 대한 알고리즘의 성능을 비교하기 위한 분석|
가장 적합한 알고리즘을 고르기 위해 성능평가와 비교가 필요하다.
어떻게 하면 **객관적**으로 분석할 수 있는가?
ex) 특정기계X, 절대적시간X
그래서 상대적인 평가를 할 수 있는 **점근적 표기법(Asymptotic notations)** 을 사용해야 한다!

- $O$-notation : 점근적 상한(_asymptotic upper bound_)아무리 느려도 기준함수보다 느리다
- $\Omega$-notation : 점근적 하한(_asymptotic lower bound_) 항상 빠르다
- $\Theta$-notation : 그 사이
  $$T(n) = 3T([n/4])+\Theta(n^2)$$
  **대체법(Substitution Method)**
  재귀알고리즘은 T(n)으로 간단히 계산하기가 쉽지 않기 때문에(자기자신을 다시 리콜하기때문에.. 다차식형태로 변환해야함)<br>해답의 형태를 추측하는 수학적 귀납법을 이용하여 추측한 해답이 맞음을 증명함.
  (다차식으로 변환하는 방법 3가지)
- Substitution Method : 값을 대체해서 계산하여 증명!!!
- Recursion-tree Method : 재귀를 트리형태로 그려보고 트리형태의 값이 무엇인지
- Master Method : 공식에 넣어서 적용

#### 재귀 트리를 이용한 성능분석

(주어진 함수에 값을 추측하고. 추측한것을 대체법을 이용하여 증명.)
재귀 함수의 성능 분석을 위해 재귀 트리를 그려 해답을 추측하고(Recursion-tree Method),<br>이를 대체법(Substitution Method)을 이용하여 증명하는 방법이 있음.
(각 노드들을 코스트로 계산, 레벨들의 합을 구하고, 전체 트리의 합을 구함. )

### Hiring문제를 이용한 확률분석

Hiring problem : 지원자 중 가장 뛰어난 직원을 고용하려고 할 때, 최소의 비용을 계산하는 문제.

고용문제는 인터뷰비용과 고용비용을 최소로 하면서<br>가장 좋은 사람을 뽑는 방법으로 이 문제를 해결하기 위한 확률분석방법을 이해함
(가장 좋은 사람이 몇 번째 인터뷰에 오느냐?+ 각각의 경우가 몇 가지인가?)

- Indicator Random Variables
- Randomized Order : 무작위성추가

### Balls and Bins 문제를 이용한 확률분석

Binomial Cistribution과 Geometric Distribution에 대해 알아보았는데<br> 확률분석의 결과가 일반적으로 생각하는 확률과 크게 다르지 않음을 확인

### 동적계획법(Dynamic Programming)

**동적계획법을 적용하기 위해서는 최적해 구조와 재귀 구조를 가져야 함.**
문제해결방법의 4가지

1. **Brute-Force Approach** : 전수조사(모든경우를 다해보고;; 가장빠르다, 가장적다라는 판결을 내리기 때문에 시간이 오래걸림)
   모든 경우의 답을 구해보는 일반적인 방법
   답이 있다면 항상 답을 탖으며 구현이 쉬운 편
   경우의 수에 비례하여 시간이 증가
   ex)약수구하기
2. **Divide and Conquer Approach** : 큰문제를 작게쪼개어 병렬적으로 해결.
   문제의 크기를 작게 나누어서 문제를 쉽게 풀기 위한 방법
   문제의 크기는 두 개 이상으로 쪼개어지고 문제의 해답을 바로 구할 수 있을 정도가 될 때까지 문제를 계속 분할
   하위 문제들이 서로 독립적이어야 함
   ex) 정렬문제(quick, merge, radix)
3. **Dynamic Programming Approach** : 주어진 문제를 하위로 나누어서 해결.(Divide and conquer와 비슷하지만 문제간의 관계가 다름)종속성을 가질 때 사용.
   하위 문제에 대한 답을 저장하였다가 동일한 문제가 나오면 재계산하지 않고 저장된 답을 사용
   ex) 피보나치 수열
4. **Greedy Approach** : 해당문제의 최적답을 고르면 전체에 답이 최적일 것이다.
   현재 상황에서 최선의 답을 선택
   현재 상황에는 최선이지만 **전체에는 최선이라는 보장은 없음**
   최적 부분 구조 조건을 만족하면 결과가 우수
   ex) 허프만코드

**동적프로그래밍의 특징**

- 모든 하위 문제를 풀고 그 결과를 저장해 둠
- 저장되어 있던 결과는 다음 단계의 문제를 푸는 데 사용(연관성)
- 동적프로그래밍은 최적화 문제를 푸는 데 쓰임

**동적프로그래밍과 최적화 문제**
가능한 해답이 무수히 존재하며,<br>각각의 해답은 숫자 등의 크기가 있는 값을 가짐<br>가장 크거나 가장 작은 최적의 값을 가지는 해답을 찾을 수 있고,<br>그런 해답을 최적화 문제의 **최적해**라고 부름<br>즉, 최적화 문제란 문제의 여러답이 서로 비교 가능하고<br>복수 개인의 경우, 목적에 따라 가장 좋은 결과를 찾아야 하는 문제.
ex) 최단경로문제

**1단계** : 최적해에 대한 구조적 특징을 분석<br>(하위 문제로부터 해답을 구해서 원래의 답을 구할 수 있는 구조인지 확인해 본다.)
**2단계** : 최적해 값을 구하기 위한 **재귀적 정의**가 가능한지 확인
**3단계** : 하위문제로부터 **최적해의 값을 계산**<br>수행시간은 $\Theta(2^n)$
**4단계** : 계산된 값으로부터 최적해를 만듦

### 동적계획법을 적용한 Assembly Line Scheduling

조립을 통해 제품이 완성될 때 여러 개의 과정과 여러 개의 라인이 존재할 때 최적의 조합을 찾아<br>**가장 빠른 시간과 경로를 동적계획법을 이용하여 해결**

### 동적계획법을 적용한 Matrix-Chain Multiplication

행렬의 곱은 그 순서에 따라 곱셈의 횟수가 달라지기 때문에 효율적으로 계산하기 위해서는 가장 최소인 경우를 찾아야 함

**수행시간**
$O(n^3)$ time in total : 주어진 매트릭스에 대해 매번 동일값을 매번 반복해서 계산.
$\Theta(n2)$ subproblems : 주어진값을 매트릭스형태로 n\*n으로 계산된값을 모든 매트릭스에 반복적용.
$O(n)$ time for each subproblem

**공간사용**
$\Theta(n^2)$

Overlapping Subproblems : 하위 문제가 반복적으로 등장하는 경우
Memoization : 하위 문제가 반복적으로 등장하는 경우 계산한 값을 저장하여 효율성을 올림

### 7강 9:49

**Greedy Approach** vs **Brute-Force approach**
현재상황의 베스트 / 정답을 고를 수 있지만시간이 걸림
베스트와 차선값이 차이가 많이 나지 않아 경향만 보고싶을때는 greedy해도 상관없다.
꼭 정확한 답이 필요하다면 Brute-Force.
**Greedy Approach** vs **Dynamic programming**
현재상황의 베스트 / 이전상황을 모두 고려한 현재상황의 베스트
**Greedy Approach** vs **Divide and Conquer**
완전 다르기때문에 이 둘은 유사성이 없다.

### 0-1 Knapsack Problem

가방이 담을 수 있는 무게가 정해져 있을때,
가방에 담은 물건들의 가치가 최고가 되도록 선택하는 문제
(엇? 앞전에 봤었는데??)
**Brute-Force** 각각의 가치를 따져서 이방법 저방법 다해보고 정답을 고름.
**Greedy** 일단 가장 가치가 최고인것부터 넣고본다.

### 8강\_ Huffman code

Huffman code는 **데이터를 압축하고 해제**하는데 광범위하게 사용되는 알고리즘으로 **유동길이 코드를 효율적으로 설정**하여 Encoding과 Decoding에 문제가 없으면서 크기를 최대한 줄이기 위해 사용한다.

- 압축(compression) : 처리 효율을 높이든가 데이터 양을 적게 하는 정보의 집약도를 높이는 등의 목적에서 통상의 데이터를 특수한 데이터 형식으로 치환하는것. 압축된 데이터는 역의 변환에 의해서 원래의 데이터로 돌아간다.

**고정길이 코드**

- 6가지 {a,b,c,d,e,f}로 구성된 십만 개의 문자를 표현한다면, 총 6가지 문자를 표현해야하므로 최소 3비트가 필요
- 3비트의 고정길이 코드(fixed-length code)로 표현한다면 300,000비트가 필요
  (000, 001, 010, 011, 100, 101)

**유동크기 코드**

- 사용공간은 고정크기가 아닌 유동크기 코드(variable-length code)를 사용하면 줄일 수 있음(Frequency에 따른 유동크기코드는 적은공간사용 224,000비트필요)
  (0, 101, 100, 111, 1101, 1100)

### Greedy Approach를 이용하여 Huffman code 풀기.

Prefix가 중복되지 않는 유동길이 코드를 만들기 위해서
모든 경우를 계산하여 가장 효율적인 방법을 고를 수도 있지만
**Greedy Approach를 이용하여 가장 빈도수가 낮은 문자들을 합치면서 트리구조를 생성**하는 방법

유동길이 코드의 압축과 해제

- Encoding and Decoding
  문자코드가 다른 문자코드의 prefix가 되면 중복이 발생함으로, 중복을 피하면서 유동길이 코드로 만들어야 함.

- Huffman code의 생성 : Greedy approach로 해결하는 방법
  1.  빈도수Frequency에 따라 오름차순으로 정렬
  2.  제일작은 1,2번을 합쳐서 부모노드를 만든다.
  3.  1.2 반복 (끝날때까지)
  4.  트리의 왼쪽은0, 오른쪽은1을 주면 Codeward가 나온다
  5.  비트계산 Frequency\*길이 (빈도수가높은건 길이를 짧게해서 비트수를 줄인다)

### 스트링매칭(String Matching)

텍스트T와 패턴P가 주어졌을 때, 'T에 P가 존재하는가?'에 대한 해답을 찾는 문제.
한 칸씩 이동하여 text가 끝날때까지 비교하여 횟수와 위치를 찾는 문제.

### KMP알고리즘

비교횟수를 최고화하는 스트링매칭 알고리즘으로 선형시간에 검색이 가능함.

비교의 횟수를 줄여서 좀더 빠르게 스트링매칭의 결과를 내고자.
불필요한 비교가 많은 기존 스트링매칭과 달리 여러칸을 옮김.
패턴P의 발생을 놓치지 않으면서 **비교 횟수를 최소화**할 수 있을것인가.

**시간복잡도** : 비교의 횟수와 패턴의 재 비교 횟수로 고려할 수 있다.
**비교의횟수** : 매치된 수 + 믹스매치된 수의 합이다.

### Exact Matching

주어진 텍스트T에서 찾고자 하는 패턴P가 발생하는 횟수와 모든 지점을 찾는 문제

### Approximate string matching(exact의 반대)

주어진 텍스트T에서 찾고자 하는 **패턴P의 일부**를 찾아서 발생하는 횟수와 모든 지점을 찾는 문제
$$(1개틀린것과 2개틀린것 p=ab*, a*a, *ba 와 a**, *b*, **a)$$
여러 번 반복해서 찾아야 하는 문제가 발생 -> 시간복잡도 증가

### Exact Set Matching(Approximate와 비슷)

주어진 텍스트T에서 찾고자 하는 **패턴P의 집합**이 주어졌을 때, 패턴 P의 집합을 효율적으로 찾는 문제
여러 번 반복해서 찾아야 하는 문제가 발생 -> 시간복잡도 증가

### Aho-Corasik알고리즘

Output-link와 Failure-link를 적용한 키워드 트리를 이용하여 Exact Set Matching문제를 선형시간에 해결이 가능
중복되는것을 한번에 검사한다 p ={pat, party} 중복pa

- 키워드 트리(Keyword Tree) 생성규칙
  1.  각 간선은 문자 하나를 할당
  2.  한 정점으로부터 간선이 두 개로 나누어졌다면 두 간선은 각기 다른 문자가 할당
  3.  패턴집합 P안의 모든 패턴들은 정점들의 집합에 모두 매칭됨
